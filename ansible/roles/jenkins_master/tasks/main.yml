---
- name: Ensure Git is installed (safe fallback for Amazon Linux)
  become: yes
  shell: |
    if ! command -v git >/dev/null 2>&1; then
      yum install -y git || dnf install -y git || amazon-linux-extras install git -y
    else
      echo "Git already installed"
    fi
  args:
    executable: /bin/bash
  register: git_install
  changed_when: "'already installed' not in git_install.stdout"

- name: Install Java 17 (required for Jenkins)
  shell: |
    amazon-linux-extras install java-openjdk17 -y || yum install -y java-17-amazon-corretto

- name: Add Jenkins repo
  get_url:
    url: https://pkg.jenkins.io/redhat-stable/jenkins.repo
    dest: /etc/yum.repos.d/jenkins.repo

- name: Import Jenkins key
  rpm_key:
    state: present
    key: https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key

- name: Install Jenkins
  shell: yum install -y jenkins
  register: install_output
  changed_when: "'Nothing to do' not in install_output.stdout"

- name: Set Jenkins Java path to Corretto 17
  lineinfile:
    path: /etc/sysconfig/jenkins
    regexp: '^JAVA_HOME='
    line: 'JAVA_HOME=/usr/lib/jvm/java-17-amazon-corretto'
    create: yes
  notify: Restart Jenkins

# Disable CSRF + enable simple automation args (you already had this)
- name: Allow Jenkins automation API (disable CSRF temporarily)
  become: yes
  lineinfile:
    path: /etc/sysconfig/jenkins
    regexp: '^JENKINS_ARGS='
    line: >-
      JENKINS_ARGS="--argumentsRealm.passwd.aegonish={{ jenkins_admin_password }}
      --argumentsRealm.roles.aegonish=admin --httpPort=8080 --csrfProtection=false"
  notify: Restart Jenkins

- name: Restart Jenkins to apply CSRF disable
  become: true
  systemd:
    name: jenkins
    state: restarted

- name: Wait for Jenkins to be ready after CSRF change
  uri:
    url: http://localhost:8080/login
    status_code: 200
  register: jenkins_after_csrf
  retries: 15
  delay: 10
  until: jenkins_after_csrf.status == 200

- name: Ensure script approval file exists
  become: yes
  copy:
    dest: /var/lib/jenkins/scriptApproval.xml
    content: |
      <scriptApproval plugin="script-security@1271.vfe18c1e88cc8">
        <approvedScriptHashes/>
        <approvedSignatures/>
        <aclApprovedSignatures/>
        <approvedClasspathEntries/>
      </scriptApproval>
    owner: jenkins
    group: jenkins
    mode: '0644'

- name: Enable and start Jenkins service
  systemd:
    name: jenkins
    enabled: yes
    state: started

- name: Wait for Jenkins service to be ready
  uri:
    url: http://localhost:8080/login
    status_code: 200
  register: result
  retries: 10
  delay: 10
  until: result.status == 200

- name: Copy plugins list
  copy:
    src: plugins.txt
    dest: /var/lib/jenkins/plugins.txt
    owner: jenkins
    group: jenkins
    mode: '0644'

- name: Gather facts again
  setup:

# ---------- plugin-management-cli (replaces plugin-installation-manager-tool, 2025 verified) ----------
- name: Ensure jenkins-plugin-cli is available
  become: true
  shell: |
    set -eux
    mkdir -p /opt/jenkins-cli

    # âœ… Official 2025 repo path for plugin-management-cli
    try_urls=(
      "https://repo.jenkins-ci.org/artifactory/releases/io/jenkins/plugin-management/plugin-management-cli/2.13.0/plugin-management-cli-2.13.0.jar"
      "https://repo.jenkins-ci.org/artifactory/releases/io/jenkins/plugin-management/plugin-management-cli/2.12.0/plugin-management-cli-2.12.0.jar"
    )

    downloaded=""
    for url in "${try_urls[@]}"; do
      echo "trying $url"
      if curl -fsSL -o /opt/jenkins-cli/plugin-installation-manager.jar "$url"; then
        downloaded="yes"
        break
      fi
    done

    if [ -z "$downloaded" ]; then
      echo "ERROR: Could not download plugin-management-cli jar" >&2
      exit 22
    fi

    cat <<'EOF' > /usr/local/bin/jenkins-plugin-cli
    #!/bin/bash
    exec java -jar /opt/jenkins-cli/plugin-installation-manager.jar "$@"
    EOF
    chmod +x /usr/local/bin/jenkins-plugin-cli
  args:
    executable: /bin/bash


# ensure plugin directory
- name: Ensure Jenkins plugins directory exists
  file:
    path: /var/lib/jenkins/plugins
    state: directory
    owner: jenkins
    group: jenkins
    mode: '0755'

# install plugins, but make loop tolerant and show output
- name: Install Jenkins plugins (safe iterative install)
  become: true
  shell: |
    set -eux
    while IFS= read -r plugin || [ -n "$plugin" ]; do
      plugin="$(echo "$plugin" | tr -d '\r\n')"
      [ -z "$plugin" ] && continue
      echo "Installing plugin: $plugin"
      /usr/local/bin/jenkins-plugin-cli --plugin-download-directory /var/lib/jenkins/plugins --plugins "$plugin" || echo "plugin install returned non-zero for $plugin (continuing)"
    done < /var/lib/jenkins/plugins.txt
  args:
    executable: /bin/bash
  environment:
    JENKINS_UC: "https://updates.jenkins.io"
    JENKINS_HOME: "/var/lib/jenkins"
  register: plugin_install
  changed_when: plugin_install.rc == 0 and plugin_install.stdout|default('') != ""
  tags:
    - jenkins_plugins

- name: Fix ownership and permissions on Jenkins plugins
  become: true
  file:
    path: /var/lib/jenkins/plugins
    owner: jenkins
    group: jenkins
    recurse: yes

- name: Disable Jenkins CSRF protection and enable script console via API (final ensure)
  become: true
  lineinfile:
    path: /etc/sysconfig/jenkins
    regexp: '^JENKINS_ARGS='
    line: 'JENKINS_ARGS="--webroot=%C/jenkins/war --httpPort=8080 --csrfProtection=false --argumentsRealm.passwd.aegonish={{ jenkins_admin_password }} --argumentsRealm.roles.aegonish=admin"'
  notify: Restart Jenkins

- name: Restart Jenkins to load new plugins
  become: true
  systemd:
    name: jenkins
    state: restarted

- name: Wait until Jenkins comes back online
  uri:
    url: http://localhost:8080/login
    status_code: 200
    timeout: 120
  register: jenkins_up
  retries: 12
  delay: 10
  until: jenkins_up.status == 200

- name: Print Jenkins initial admin password
  command: cat /var/lib/jenkins/secrets/initialAdminPassword
  register: admin_pass
  failed_when: false
  changed_when: false

- debug:
    msg: "Jenkins initial admin password: {{ admin_pass.stdout | default('Already initialized or file missing') }}"
